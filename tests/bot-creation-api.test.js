// tests/bot-creation-api.test.js
/**
 * Tests d'int√©gration pour l'API de cr√©ation de bot √©tendue
 * Teste l'API avec les nouveaux champs et la validation Zod
 */

import { strict as assert } from 'assert';
import http from 'http';

// Configuration pour les tests
const TEST_CONFIG = {
  BASE_URL: 'http://localhost:3000',
  API_ENDPOINT: '/api/bots/create',
  TIMEOUT: 10000
};

// Helper pour faire des requ√™tes HTTP
function makeRequest(method, path, headers = {}, body = null) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, TEST_CONFIG.BASE_URL);
    
    const options = {
      hostname: url.hostname,
      port: url.port,
      path: url.pathname + url.search,
      method: method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      timeout: TEST_CONFIG.TIMEOUT
    };

    const req = http.request(options, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        try {
          const parsedData = data ? JSON.parse(data) : null;
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            data: parsedData
          });
        } catch (error) {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            data: data
          });
        }
      });
    });

    req.on('error', reject);
    req.on('timeout', () => {
      req.destroy();
      reject(new Error(`Request timeout after ${TEST_CONFIG.TIMEOUT}ms`));
    });

    if (body) {
      req.write(JSON.stringify(body));
    }
    
    req.end();
  });
}

// Configurations de test
const validBotConfig = {
  name: 'Test Bot API',
  description: 'Bot de test pour l\'API √©tendue avec validation Zod compl√®te',
  initialAllocation: {
    initialAmount: 5000,
    baseCurrency: 'USD',
    autoRebalance: true,
    rebalanceFrequency: 24
  },
  strategyHints: ['momentum', 'trend_following'],
  riskLimits: {
    maxAllocation: 0.15,
    maxDailyLoss: 0.03,
    maxPositionSize: 0.10,
    stopLoss: 0.025,
    takeProfit: 0.06,
    maxDrawdown: 0.12
  },
  riskLevel: 'medium',
  targetPairs: ['BTC/USD', 'ETH/USD', 'ADA/USD'],
  preferredIndicators: ['RSI', 'MACD', 'EMA', 'BB'],
  enableBacktest: true,
  advancedConfig: {
    aiOptimization: true,
    tradingFrequency: 30,
    notifications: true
  }
};

const minimalBotConfig = {
  name: 'Minimal Bot',
  description: 'Configuration minimale valide pour test',
  initialAllocation: {
    initialAmount: 1000,
    baseCurrency: 'USD',
    autoRebalance: false
  },
  strategyHints: ['dca'],
  riskLimits: {
    maxAllocation: 0.08,
    maxDailyLoss: 0.02,
    maxPositionSize: 0.06,
    stopLoss: 0.015,
    maxDrawdown: 0.10
  }
};

const highFreqBotConfig = {
  name: 'Scalping Bot',
  description: 'Bot de scalping haute fr√©quence avec limites strictes',
  initialAllocation: {
    initialAmount: 2000,
    baseCurrency: 'USD',
    autoRebalance: false
  },
  strategyHints: ['scalping'],
  riskLimits: {
    maxAllocation: 0.08,
    maxDailyLoss: 0.03,
    maxPositionSize: 0.05,
    stopLoss: 0.01,
    maxDrawdown: 0.08
  },
  targetPairs: ['BTC/USD'],
  preferredIndicators: ['VOLUME', 'ATR'],
  advancedConfig: {
    aiOptimization: false,
    tradingFrequency: 1,
    notifications: true
  }
};

function getAuthHeaders() {
  // Mock headers d'authentification pour les tests
  return {
    'Authorization': 'Bearer test-token',
    'User-Agent': 'Bot-Creation-Test-Client/1.0'
  };
}

// Tests de l'API
async function runAPITests() {
  console.log('ü§ñ Tests API de cr√©ation de bot √©tendue...\n');
  
  let serverRunning = false;
  
  // Test de connectivit√©
  try {
    console.log('üîå Test de connectivit√© au serveur...');
    await makeRequest('GET', '/');
    serverRunning = true;
    console.log('‚úÖ Serveur accessible\n');
  } catch (error) {
    console.log('‚ùå Serveur non accessible:', error.message);
    console.log('üí° D√©marrez le serveur avec: npm run dev\n');
    return false;
  }

  if (!serverRunning) return false;

  // Test 1: Cr√©ation avec configuration compl√®te
  await test('Cr√©ation avec configuration compl√®te', async () => {
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), validBotConfig);
    
    console.log(`   Status: ${response.statusCode}`);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    if (response.statusCode !== 201) {
      console.log(`   Response: ${JSON.stringify(response.data, null, 2)}`);
    }
    
    assert.strictEqual(response.statusCode, 201, 'Cr√©ation devrait retourner 201');
    assert(response.data.id, 'R√©ponse devrait contenir un ID');
    assert(response.data.validationInfo, 'R√©ponse devrait contenir validationInfo');
    assert.strictEqual(response.data.name, validBotConfig.name, 'Nom devrait correspondre');
    assert.strictEqual(response.data.description, validBotConfig.description, 'Description devrait correspondre');
    
    // V√©rifier les informations de validation
    assert(response.data.validationInfo.riskLevel, 'Niveau de risque devrait √™tre calcul√©');
    assert(response.data.validationInfo.strategiesApplied, 'Strat√©gies appliqu√©es devraient √™tre list√©es');
    assert(response.data.validationInfo.configCompliance === 'valid', 'Configuration devrait √™tre valide');
    
    console.log(`   ‚úÖ Bot cr√©√©: ${response.data.id}`);
    console.log(`   üìä Niveau de risque: ${response.data.validationInfo.riskLevel}`);
    console.log(`   üéØ Strat√©gies: ${response.data.validationInfo.strategiesApplied.join(', ')}`);
  });

  // Test 2: Cr√©ation avec configuration minimale
  await test('Cr√©ation avec configuration minimale', async () => {
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), minimalBotConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 201, 'Configuration minimale devrait √™tre accept√©e');
    assert(response.data.validationInfo.riskLevel, 'Niveau de risque devrait √™tre auto-calcul√©');
    
    console.log(`   ‚úÖ Bot minimal cr√©√© avec niveau de risque: ${response.data.validationInfo.riskLevel}`);
  });

  // Test 3: Configuration haute fr√©quence
  await test('Cr√©ation bot haute fr√©quence', async () => {
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), highFreqBotConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 201, 'Bot haute fr√©quence avec limites strictes devrait √™tre accept√©');
    
    console.log(`   ‚úÖ Bot scalping cr√©√© avec fr√©quence: ${highFreqBotConfig.advancedConfig.tradingFrequency}min`);
  });

  // Test 4: Validation - Nom invalide
  await test('Validation - Nom trop court', async () => {
    const invalidConfig = { ...minimalBotConfig, name: 'AB' };
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Nom invalide devrait retourner 400');
    assert(response.data.error, 'Erreur devrait √™tre pr√©sente');
    assert(response.data.details, 'D√©tails de validation devraient √™tre pr√©sents');
    
    console.log(`   ‚úÖ Validation du nom rejet√©e correctement`);
  });

  // Test 5: Validation - Description manquante
  await test('Validation - Description manquante', async () => {
    const invalidConfig = { ...minimalBotConfig };
    delete invalidConfig.description;
    
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Description manquante devrait retourner 400');
    
    console.log(`   ‚úÖ Validation description rejet√©e correctement`);
  });

  // Test 6: Validation - Allocation excessive
  await test('Validation - Allocation excessive', async () => {
    const invalidConfig = {
      ...minimalBotConfig,
      riskLimits: {
        ...minimalBotConfig.riskLimits,
        maxAllocation: 0.8 // 80% - trop √©lev√©
      }
    };
    
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Allocation excessive devrait retourner 400');
    
    console.log(`   ‚úÖ Validation allocation excessive rejet√©e`);
  });

  // Test 7: Validation - Strat√©gie haute fr√©quence avec limites inad√©quates
  await test('Validation - Scalping avec limites trop √©lev√©es', async () => {
    const invalidConfig = {
      ...minimalBotConfig,
      strategyHints: ['scalping'],
      riskLimits: {
        ...minimalBotConfig.riskLimits,
        maxPositionSize: 0.15, // 15% - trop pour scalping
        maxDailyLoss: 0.08     // 8% - trop pour scalping
      }
    };
    
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Scalping avec limites √©lev√©es devrait retourner 400');
    
    console.log(`   ‚úÖ Validation contraintes haute fr√©quence rejet√©e`);
  });

  // Test 8: Validation - Auto-rebalance sans fr√©quence
  await test('Validation - Auto-rebalance sans fr√©quence', async () => {
    const invalidConfig = {
      ...minimalBotConfig,
      initialAllocation: {
        ...minimalBotConfig.initialAllocation,
        autoRebalance: true
        // rebalanceFrequency manquant
      }
    };
    
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Auto-rebalance sans fr√©quence devrait retourner 400');
    
    console.log(`   ‚úÖ Validation auto-rebalance rejet√©e`);
  });

  // Test 9: Validation - Trop de strat√©gies
  await test('Validation - Trop de strat√©gies', async () => {
    const invalidConfig = {
      ...minimalBotConfig,
      strategyHints: ['momentum', 'scalping', 'grid', 'arbitrage', 'dca', 'swing'] // 6 strat√©gies - max 5
    };
    
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), invalidConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    assert.strictEqual(response.statusCode, 400, 'Trop de strat√©gies devrait retourner 400');
    
    console.log(`   ‚úÖ Validation nombre de strat√©gies rejet√©e`);
  });

  // Test 10: Structure de r√©ponse enrichie
  await test('Structure de r√©ponse enrichie', async () => {
    const response = await makeRequest('POST', TEST_CONFIG.API_ENDPOINT, getAuthHeaders(), validBotConfig);
    
    if (response.statusCode === 401) {
      console.log('   ‚ö†Ô∏è  Authentification requise - skip test');
      return;
    }
    
    if (response.statusCode === 201) {
      // V√©rifier la structure enrichie
      const requiredFields = ['id', 'name', 'description', 'strategy', 'aiConfig', 'validationInfo'];
      for (const field of requiredFields) {
        assert(field in response.data, `Le champ '${field}' devrait √™tre pr√©sent`);
      }
      
      // V√©rifier validationInfo
      const validationInfo = response.data.validationInfo;
      assert(validationInfo.riskLevel, 'riskLevel devrait √™tre pr√©sent');
      assert(validationInfo.configCompliance, 'configCompliance devrait √™tre pr√©sent');
      assert(Array.isArray(validationInfo.strategiesApplied), 'strategiesApplied devrait √™tre un array');
      assert(validationInfo.riskScore, 'riskScore devrait √™tre pr√©sent');
      
      console.log(`   ‚úÖ Structure de r√©ponse compl√®te et enrichie`);
    }
  });

  return true;
}

// Helper pour les tests
async function test(name, fn) {
  try {
    console.log(`üß™ ${name}...`);
    await fn();
  } catch (error) {
    console.error(`‚ùå Test √©chou√©: ${name}`);
    console.error(`   Erreur: ${error.message}`);
    throw error;
  }
}

// Fonction principale
async function main() {
  try {
    console.log('üéØ Tests API Bot Creation Extended\n');
    console.log('========================================\n');
    
    const apiWorking = await runAPITests();
    
    if (apiWorking) {
      console.log('\nüéâ Tests API termin√©s avec succ√®s !');
    }
    
  } catch (error) {
    console.error('\n‚ùå Erreur durant les tests API:', error.message);
    process.exit(1);
  }
}

// Ex√©cuter si appel√© directement
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { runAPITests };